# It's Alive!

## a) lab1

As usual, I want to see what is the problem.

```bash
$ wget https://terokarvinen.com/application-hacking/lab1.zip
$ unzip lab1.zip
$ cd lab1/
$ ./gdb_example1
Khoor/#zruog1
Segmentation fault
```

The program prints a text, then gets the segmentation fault&mdash;or prints *"Segmentation fault"* literally&mdash;and exits. I just want to make sure the program does not print the error string itself. Who knows!

```bash
$ ./gdb_example1 || echo $?
Khoor/#zruog1
Segmentation fault
139
```

Because this task is only about investigating the root cause of the problem and how to fix it, I'll go straight to the source code. The first and only thing, which catches my eyes, is one of the big mistakes of programming: *dereferencing a NULL pointer.* 

```c
int main()
{
  char * bad_message = NULL; // Okay...
  char * good_message = "Hello, world.";

  print_scrambled(good_message);
  print_scrambled(bad_message); // Wait! On purpose???
}
```

It is such the most common mistake that every developer makes or faces in their professional career. It leads to the error we met at the beginning: *segmentation fault*. As far as I know, this error has many other names: [memory access violation](https://learn.microsoft.com/en-us/shows/inside/c0000005), null pointer exception (Java), null reference exception (C#). There is even a story about it: [the billion-dollar mistake](https://en.wikipedia.org/wiki/Null_pointer#History). The error, when it happens, will crash the program immediately. This behavior is done by modern operating systems&mdash;such as Windows, Linux, Mac OS&mdash;to prevent any further damage the error might cause.

**How to fix:** Actually I don't know what is the exact purpose of Lari's asking a question but with an answer in there. Probably it is simply **to remove the lines that cause the problem.** It is about doing only the good things, isn't it?

* Fix the source code

```c
int main()
{
  char * good_message = "Hello, world.";

  print_scrambled(good_message);
}
```

* Re-compile and run

```bash
$ gcc -Wall -g -o gdb_example1_fixed gdb_example1.c
$ ./gdb_example1_fixed || echo $?
Khoor/#zruog1
```

## b) lab2

> ***TL;DR;*** `dgOMm-x1` is the password and `FLAG{Lari-rsvRDx04WMBZpuwg4qfYwzdcvVa0oym}` is the flag.

Let's see what we have in the zip file.

```bash
$ wget https://terokarvinen.com/application-hacking/lab2.zip
$ unzip lab2.zip
$ cd lab2
```

Well, it's the same old passtr program, I guess.

* passtr

```bash
$ ./passtr
What's the password?
test
Sorry, no bonus.
$ strings passtr
...
sala-hakkeri-321
Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}
Sorry, no bonus.
...
$ ./passtr
What's the password?
sala-hakkeri-321
Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}
```

* passtr2o

```bash
$ ./passtr2o
What's the password?
test
Sorry, no bonus.
$ strings passtr2o
...
(nothing useful)
...
$ file passtr2o
passtr2o: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c83fca0527d609d8f3533ab2a9bd7fdcbe228a0c, for GNU/Linux 3.2.0, not stripped
```

Interesting! There is no low hanging fruit here. It's time to open Ghidra and let's see what we can explore there.

![Analyze with Ghidra to start reverse engineering](screenshots/lab2/01.png)

Code is easier to read if variables have their meanings. Let's follow me to see how I *decode* to read the code.

Variable `local_7e` contains part of fail message, `"Sorry, no"`&mdash;I rename it to `fail_msg`. Line 15 and 23 means that, after those, this variable now contains the whole fail message&mdash;`"Sorry, no bonus.\n"`, exactly 18 characters. In addition, this variable is an array of 38 characters in length. Therefore, 20 remaining allocated memory will contain something else. So I mark it using Ghidra's Highight feature and convert all `0x12` (hex) to `18` (dec) for better understanding.

![Rename variable local_7e to fail_msg](screenshots/lab2/02.png)

Based on the behavior of the program, and the main logic, I'm quite sure there is only one `printf` called at line 34. That means that, `pcVar4` should be the message to be printed&mdash;I rename it to `pcMessage`. Wow, a lot of `pcMessage` appear. It seems this variable is used multiple times with different purposes&mdash;Hey developer, single responsibility principle, please! 

![Rename variable pcVar4 to pcMessage](screenshots/lab2/03.png)

Anyway, at this time, I only want to focus on how the fail/success message is printed out. So I trace from line 34, where `printf` is called, backward to where the `pcMessage` variable changes its role, or in another words, it is assigned a new value. And, ta-da!

```c
Line 29:  pcMessage = fail_msg;
Line 30:  if (iVar1 == 1) {
Line 31:    pcMessage = local_58;
Line 32:    EaseEAs(pcMessage);
Line 33:  }
Line 34:  printf(pcMessage);
```  

Things become much clearer, don't they? `pcMessage`  is now first assigned to the fail message; if `iVar1 == 1`, it will be another message. What can be *another message*? It's definitely the success message&mdash;I'm 100% sure! Now I have two new variable names, `iVar1` to `iSuccess`, and `local_58` to `success_msg`.

![Rename variable iVar1 to iSuccess and local_58 to success_msg](screenshots/lab2/04.png)

I know I'm close to the finish line. Tracing the `iSuccess` variable can give me what I want&mdash;the hidden password, and the flag. Let's do that! I trace the variable to where it is assigned a value.

```c
Line 28:  iSuccess = mAsdf3a(&local_87,fail_msg + 18);
```

Gotcha! It is `mAsdf3a`-ing between `&local_87` and `fail_msg + 18`&mdash;the input, right? To make sure, I find all the `fail_msg + 18` in the code. Until I find this line

```c
Line 25:  __isoc99_scanf(&DAT_00102019,fail_msg + 18);
```

A-ha! `scanf` is a function in C which reads the user input, and stores it into&hellip;`fail_msg + 18`. Exactly what I predicted. 

`mAsdf3a` should be *verifying* or *comparing*. And, `&local_87` should be&hellip; **the password**. Yes! `password` must be the name of its. And of course, it deserves a highlight&mdash;*as bright and shiny as the light at the end of a passage!* 

![Rename variable local_87 to password and highlight it](screenshots/lab2/05.png)

Trace it! The finish line. 

```c
Line 24:  password = 0x3875346a544c6e61;
```

By hovering on the hex value that is assigned to the `password` variable, I get this information. 

![Reveal the password](screenshots/lab2/06.png)

`8u4jTLna`&mdash;the password, it must be! I open a terminal and try it, waiting for the success message popping up. 

```bash
$ ./passtr2o
What's the password?
8u4jTLna
Sorry, no bonus.
```

Oh no!&mdash;I feel a glimpse of dissappointment. Don't give up!&mdash;I think to myself&mdash;The victory is near. I continue the journey by *retyping* the `password` variable so that the hexes become a string, or an array of character&mdash;or whatever, as long as it's not a sequence of hexes. 

![Retype the password variable to string](screenshots/lab2/07.png)

Wait! Something wrong. `8u4jTLna` becomes `anLTj4u8`. It's weird. But you know, who cares! Maybe, this time&hellip;

```bash
$ ./passtr2o
What's the password?
anLTj4u8
Sorry, no bonus.
```

Well, it's not that easy!&mdash;I must admit. But, if it's that easy, it's not challenging any more, isn't it?

The remaining clue is the `mAsdf3a` function. Let's dive into it.

![The mAsdf3a function](screenshots/lab2/08.png)

We already know its signature, right? Let's modify it for better code readability.

![Change the signature of the mAsdf3a function](screenshots/lab2/09.png)

Everthing becomes sharper. Based on its flow of logic, I rename all the varibales that I can regconize its purpose. 

![Rename all variables in the mAsdf3a function](screenshots/lab2/10.png)

Well, it's hard to explain all the logic. It's just about *obfuscating* the password, and it's kind of complicated. So instead of explaining the logic, I think I will write a program to simulate the logic and it will print the password. It must be easier for us to understand&mdash;or, we don't need to know it anyway!

The logic of this *helper* program&mdash;let's call it a *keygen*&mdash;is slightly different from the original `mAsdf3a` function. Because I only want to print the password, I *void* the function (i.e. change its return type to `void`), and replace all `return` command with `printf`. Then, I remove all unnecessary codes such as the `pcInput` parameter, unused variables, dead code, etc. Finally, I compile it and name it `passtr2o_keygen`.  

```bash
$ gcc -Wall -o passtr2o_keygen passtr2o_keygen.c
```

* Source: [passtr2o_keygen.c](lab2/passtr2o_keygen.c)
* Binary: [passtr2o_keygen](lab2/passtr2o_keygen)

Now, let's try.

```bash
$ ./passtr2o_keygen 8u4jTLna
;n7cWEqZ
$ ./passtr2o                
What's the password?
;n7cWEqZ
Sorry, no bonus.
```

One more try.

```bash
$ ./passtr2o_keygen anLTj4u8
dgOMm-x1
$ ./passtr2o
What's the password?
dgOMm-x1
Yes! That's the password. FLAG{Lari-rsvRDx04WMBZpuwg4qfYwzdcvVa0oym}
```

Hooray! I did it! I found the password, and the flag!

## c) lab3

> ***Tips!*** After the *lab2* task, I found a useful video of Low Level TV (2025) talking about tools that we can use in our *hacking* tasks. The link to the video can be found in [References](#references) section below.

First, I clone the git repo of NoraCodes's crackmes challenges. 

```bash
$ git clone https://github.com/NoraCodes/crackmes.git
$ cd crackmes/
```

Because I'm using a Linux ARM64, I have to remove the `-m64` flag, or `gcc` won't compile.

Makefile
```make
...
# Compiler flags for x86_64
CCFLAGS64 := $(CCFLAGS) # Remove -m64 flag
...
```

Then I compile the source codes to get the binaries for the challenges.

```bash
$ make crackme03
make crackme03.64
make[1]: Entering directory '/home/sherlock/Projects/crackmes'
gcc -O1 -fno-stack-protector -lcrypt crackme03.c -o crackme03.64
objcopy -g crackme03.64
make[1]: Leaving directory '/home/sherlock/Projects/crackmes'
```

```bash
$ make crackme04
make crackme04.64
make[1]: Entering directory '/home/sherlock/Projects/crackmes'
gcc -O1 -fno-stack-protector -lcrypt crackme04.c -o crackme04.64
objcopy -g crackme04.64
make[1]: Leaving directory '/home/sherlock/Projects/crackmes'
```

Now let's begin our adventure!

### crackme03

> ***TL;DR;*** `nDoEiA` is the solution. 

Let's see any low hanging fruit we can find.

```bash
$ ./crackme03.64
Need exactly one argument.
$ ./crackme03.64 password
No, password is not correct.
$ strings crackme03.64
(stripped)
...
$hc8Ehc8 <== Suspicious!!!
Need exactly one argument.
Yes, %s is correct!
No, %s is not correct.
lAmBdA <== Suspicious!!!
...
$ ./crackme03.64 '$hc8Ehc8'
No, $hc8Ehc8 is not correct.
$ ./crackme03.64 lAmBdA
No, lAmBdA is not correct.
```

Well, there's no low hanging fruit for us. It's time to use Ghidra. Like other crackme challenges, the `main` function also has 2 parameters: `argc`&mdash;number of arguments passed to the program, and `argv`&mdash;the argument vector. 

![Analyze then rename and retype argc and argv parameters](screenshots/lab3/crackme03/01.png)

The logic is quite clear. The program takes the input from the first command line argument&mdash;`__s` or `argv[1]`, then uses it to do *something* with variables `local_8` and `local_10`, using the `check_pw` function. Thanks to good developers, the function is properly named: `check_pw` definitely means *checking password*. So I rename `local_8` and `local_10` to `password` and `password_extra`, respectively. 

![Rename local_8 and local_10 to password and password_extra](screenshots/lab3/crackme03/02.png)

One thing noticeable is that there is a condition which makes sure the input string has exactly 6 characters to succeed the password check.

```c
Line 23:    if ((sVar2 == 6) && (iVar1 = check_pw(__s,&password,&password_extra), iVar1 != 0)) {
```

I regconize one text I found when using `strings` command to look for low hanging fruits. `lAmBdA`&mdash;exactly 6 characters&mdash;it must be the password. So I retype the `password` variable to 7-length char array instead of `undefined8`. You may ask why we need a 7-length array while it has 6 characters. [Can Özkan (20 November 2025)](#references) explains in technical details about the *null-terimnated strings* in C.

![Retype password to 7-length char array](screenshots/lab3/crackme03/03.png)

The remaining clue is in the `check_pw` function. Based on how it is called at line 23, I rename and retype all variables in the function. 

```c
undefined8 check_pw(char *input,char *password,char *password_extra)

{
  long i;
  
  i = 0;
  while( true ) {
    if (input[i] != (byte)(password[i] + password_extra[i])) {
      return 0;
    }
    if (password[i + 1] == '\0') break;
    i = i + 1;
    if (input[i] == '\0') {
      return 1;
    }
  }
  return 1;
}
```

The logic is clear: for each character of the password&mdash;`lAmBdA`, offset it with a proper value depending on the position of the character. Therefore, the `password_extra` variable in the `main` function must be a 7-length array of `byte`, which contains the offset values. So I decide to retype it to `byte[7]`. Let's look at what I find.

![Retype password_extra to 7-length byte array in main](screenshots/lab3/crackme03/04.png)

From now, with the help of the `ascii` utility, I can easily compute the hidden password. 

```
108 + 2 = 110  l --> n
 65 + 3 =  68  A --> D
109 + 2 = 111  m --> o
 66 + 3 =  69  B --> E
100 + 5 = 105  d --> i
 65 + 0 =  65  A --> A
```

Let's try to see if it's the correct one or not.

```bash
$ ./crackme03.64 nDoEiA
Yes, nDoEiA is correct!
```

Bingo!

### crackme04

By performing the same chain of logics to *reverse engineer* the program, here is what I find in Ghidra's decompiled code.

```c
undefined8 main(int argc,char **argv)

{
  long counter;
  undefined8 uVar1;
  char *uInput;
  int sum_of_char_code;
  char cInputLetter;
  long l1;
  
  if (argc == 2) {
    cInputLetter = *argv[1];
    sum_of_char_code = 0;
    l1 = 1;
    if (cInputLetter != '\0') {
      do {
        counter = l1;
        sum_of_char_code = sum_of_char_code + (uint)(byte)cInputLetter;
        cInputLetter = argv[1][counter];
        l1 = counter + 1;
      } while (cInputLetter != 0);
      if (sum_of_char_code == 1762 && (int)counter == 16) {
        __printf_chk(2,"Yes, %s is correct!\n");
        return 0;
      }
    }
    __printf_chk(2,"No, %s is not correct.\n");
    uVar1 = 1;
  }
  else {
    puts("Need exactly one argument.");
    uVar1 = 0xffffffff;
  }
  return uVar1;
}
```

I figure out that every password, which has 16 characters and its sum of ASCII codes of characters equals 1762, is correct. So, it can be `oonnnnnnnnnnnnnn`.

```bash
$ ./crackme04.64 oonnnnnnnnnnnnnn
Yes, oonnnnnnnnnnnnnn is correct!
```

And a few more.

```bash
$ ./crackme04.64 nnnnnnnnnnnnnnnp
Yes, nnnnnnnnnnnnnnnp is correct!
```

```bash
$ ./crackme04.64 zzzzzzzzzzzzKKJJ
Yes, zzzzzzzzzzzzKKJJ is correct!
```

You can use AI and ask it: *"Give me some examples of C string that is exactly 16 alphanumeric long and its sum of ASCII codes equals 1762."* But remember to test it because I received some false answers before, when I tried to find some passwords for this crackme task according to my find out above. AI is not that smart and its answers are not always true. Trust me!

# References

* Özkan, C. 20 November 2025. Strings in C: A Deep Technical Exploration. Medium blog. URL: https://can-ozkan.medium.com/strings-in-c-a-deep-technical-exploration-cffc14f362b0. Accessed: February 13, 2025.
* Low Level 29 October 2025. Every Level of Reverse Engineering Explained. Online video. URL: https://www.youtube.com/watch?v=8vk5z9VAaBQ. Accessed: February 13, 2025.
* Microsoft Inside Show 2018. Access Violation C0000005. Jan 29, 2018. Online video. URL: https://learn.microsoft.com/en-us/shows/inside/c0000005. Accessed: February 9, 2026.
* Wikipedia 2026. Null pointer. January 30, 2026. URL: https://en.wikipedia.org/wiki/Null_pointer#History. Accessed: February 9, 2026
* Wikipedia 2026. Segmentation fault. January 12, 2026. URL: https://en.wikipedia.org/wiki/Segmentation_fault. Accessed: February 9, 2026.